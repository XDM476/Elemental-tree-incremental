<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Elemental Tree Incremental</title>
<style>
  body {
    background: #000;
    color: #fff;
    font-family: 'Trebuchet MS', sans-serif;
    text-align: center;
    margin: 0;
    padding: 0;
  }

  header {
    padding: 20px;
    background: rgba(0, 0, 0, 0.3);
    font-size: 2rem;
    letter-spacing: 2px;
  }

  main {
    margin-top: 50px;
  }

  .currency {
    font-size: 1.5rem;
    margin: 20px;
  }

  .value {
    font-weight: bold;
    color: #00ffff;
  }
  
  #heliumInfo {
    margin: 20px 0;
    padding: 10px;
    background: rgba(255, 85, 85, 0.1);
    border-radius: 10px;
  }

    /* Upgrade Tree */
  .tree {
    display: grid;
    grid-template-areas: 
      "up1 up2 up3"
      ". up4 .";
    justify-content: center;
    gap: 40px;
    margin-top: 50px;
    position: relative;
  }

  .upgrade {
    background: grey; /* default: not bought */
    padding: 15px 25px;
    border-radius: 10px;
    cursor: pointer;
    transition: 0.2s;
    position: relative;
    z-index: 1; 
    color: #fff;
  }  .upgrade.bought {
    background: green; /* bought */
  }

  .upgrade.affordable:not(.bought) {
    background: rgba(0, 255, 255, 0.2); /* affordable hover color */
  }

  .lines {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    z-index: 0;
  }

  .line {
    position: absolute;
    background: #00ffff;
    height: 2px;
    z-index: 0;
  }

  /* SVG connector styling */
  svg.lines {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    overflow: visible;
    pointer-events: none; /* let clicks pass through to upgrades */
  }
  svg.lines line {
    stroke: #00ffff;
    stroke-width: 2;
    stroke-linecap: round;
  }

  footer {
    position: absolute;
    bottom: 10px;
    width: 100%;
    font-size: 0.8rem;
    color: #aaa;
  }

  .reset-button {
    margin-top: 30px;
    padding: 10px 20px;
    font-size: 1rem;
    border-radius: 10px;
    cursor: pointer;
    background: #ff5555;
    color: #fff;
    border: none;
    transition: 0.2s;
  }

  .reset-button:hover {
    background: #ff0000;
  }

  .save-buttons {
    margin-top: 20px;
    display: flex;
    justify-content: center;
    gap: 10px;
  }

  .save-button {
    padding: 8px 16px;
    font-size: 0.9rem;
    border-radius: 8px;
    cursor: pointer;
    background: #004455;
    color: #fff;
    border: none;
    transition: 0.2s;
  }

  .save-button:hover {
    background: #006677;
  }
</style>
</head>
<body>
  <header>Elemental Tree Incremental</header>

  <main>
    <div class="currency">
      Hydrogen: <span id="hydrogen" class="value">0</span>
    </div>
    <div class="currency">
      Hydrogen Rate: <span id="hydrogenRate" class="value">1</span>/sec
    </div>
    <div id="heliumInfo" style="display: none;">
      <div class="currency">
        Helium: <span id="helium" class="value">0</span>
      </div>
      <div class="currency">
        Helium on Reset: <span id="heliumGain" class="value">0</span>
      </div>
    </div>

    <!-- Upgrade Tree -->
    <div class="tree">
      <div class="upgrade" id="upgrade1" data-cost="20" style="grid-area: up1;">H-Upgrade 1 (Cost: 20 Hydrogen)</div>
      <div class="upgrade" id="upgrade2" data-cost="50" style="grid-area: up2;">H-Upgrade 2 (Cost: 50 Hydrogen)</div>
      <div class="upgrade" id="upgrade3" data-cost="125" style="grid-area: up3;">H-Upgrade 3 (Cost: 125 Hydrogen)</div>
      <div class="upgrade" id="upgrade4" data-cost="500" style="grid-area: up4;">H-upgrade 4 (cost: 500 Hydrogen)</div>
      <button class="reset-button" id="heliumResetButton" style="grid-area: up4; margin-top: 60px;">Reset for Helium</button>
      <!-- Use an SVG for connector lines so we can draw diagonal lines cleanly -->
      <svg class="lines" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">
        <line id="line1-4" />
        <line id="line2-4" />
        <line id="line3-4" />
        <line id="lineH" />
        <line id="lineStem" />
        <line id="lineHelium" style="display: none" />
      </svg>
    </div>

    <!-- Reset Button -->
    <button class="reset-button" id="resetButton">Reset Data</button>
    
    <!-- Save Management -->
    <div class="save-buttons">
      <button class="save-button" id="exportButton">Export Save</button>
      <button class="save-button" id="importButton">Import Save</button>
      <input type="file" id="importInput" style="display: none;" accept=".txt">
    </div>
  </main>

  <footer>Your progress is saved automatically every 5 seconds</footer>

<script>
let hydrogen = 0;
let hydrogenRate = 1;

// Track purchased upgrades
let upgradesBought = {
  upgrade1: false,
  upgrade2: false,
  upgrade3: false,
  upgrade4: false
};

const hydrogenDisplay = document.getElementById('hydrogen');
const hydrogenRateDisplay = document.getElementById('hydrogenRate');
const upgradeElements = {
  upgrade1: document.getElementById('upgrade1'),
  upgrade2: document.getElementById('upgrade2'),
  upgrade3: document.getElementById('upgrade3'),
  upgrade4: document.getElementById('upgrade4')
};

function updateDisplay() {
  hydrogenDisplay.textContent = hydrogen.toLocaleString();
  hydrogenRateDisplay.textContent = hydrogenRate.toLocaleString();
  updateUpgradeStates();
  updateLines();
}

// Generate a unique player ID
function generatePlayerId() {
  return 'player_' + Math.random().toString(36).substr(2, 9);
}

// Get or create player ID
function getPlayerId() {
  let playerId = localStorage.getItem('elementalPlayerId');
  if (!playerId) {
    playerId = generatePlayerId();
    localStorage.setItem('elementalPlayerId', playerId);
  }
  return playerId;
}

// Get save key for current player
function getPlayerSaveKey() {
  return 'elementalSave_' + getPlayerId();
}

// Encode save data to Base64
function encodeGameState(data) {
  return btoa(JSON.stringify(data));
}

// Decode save data from Base64
function decodeGameState(encoded) {
  try {
    return JSON.parse(atob(encoded));
  } catch (e) {
    console.error('Failed to decode save:', e);
    return null;
  }
}

// Create save data object
function createSaveData() {
  return {
    playerId: getPlayerId(),
    hydrogen,
    hydrogenRate,
    helium,
    upgradesBought,
    version: '1.0',
    timestamp: Date.now()
  };
}

// Load saved game
function loadGame() {
  try {
    // Get player-specific save from localStorage
    const localData = localStorage.getItem(getPlayerSaveKey());
    
    let saveData = null;
    
    if (localData) {
      saveData = decodeGameState(localData);
      // Verify this save belongs to the current player
      if (saveData && saveData.playerId === getPlayerId()) {
        hydrogen = saveData.hydrogen || 0;
        hydrogenRate = saveData.hydrogenRate || 1;
        helium = saveData.helium || 0;
        upgradesBought = saveData.upgradesBought || {
          upgrade1: false,
          upgrade2: false,
          upgrade3: false,
          upgrade4: false
        };
        updateDisplay();
      }
    }
  } catch (e) {
    console.error('Failed to load save:', e);
  }
}

// Save game
function saveGame() {
  try {
    const saveData = createSaveData();
    const encoded = encodeGameState(saveData);
    
    // Save to player-specific storage
    localStorage.setItem(getPlayerSaveKey(), encoded);
    
  } catch (e) {
    console.error('Failed to save:', e);
  }
}

// Export save as file
function exportSave() {
  const saveData = createSaveData();
  const blob = new Blob([JSON.stringify(saveData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `elemental-save-${getPlayerId()}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Hydrogen generation loop
setInterval(() => {
  hydrogen += hydrogenRate;
  updateDisplay();
}, 1000);

// Update upgrade visual state and affordability
function updateUpgradeStates() {
  for (const id in upgradeElements) {
    const el = upgradeElements[id];
    const cost = parseInt(el.dataset.cost);

    if (upgradesBought[id]) {
      el.classList.add('bought');
      el.classList.remove('affordable');
    } else {
      el.classList.remove('bought');
      if (hydrogen >= cost) {
        el.classList.add('affordable');
      } else {
        el.classList.remove('affordable');
      }
    }
  }
  
  // Show/hide helium reset button based on upgrade4 status
  const heliumResetButton = document.getElementById('heliumResetButton');
  heliumResetButton.style.display = upgradesBought.upgrade4 ? 'block' : 'none';
}

// Upgrade click handlers
function buyUpgrade(id, multiplier) {
  const el = upgradeElements[id];
  const cost = parseInt(el.dataset.cost);

  if (!upgradesBought[id]) {
    if (hydrogen >= cost) {
      hydrogen -= cost;
      hydrogenRate *= multiplier;
      upgradesBought[id] = true;
      updateDisplay();
      saveGame();
    } else {
      alert("Not enough Hydrogen!");
    }
  }
}

upgradeElements.upgrade1.onclick = () => buyUpgrade('upgrade1', 2);
upgradeElements.upgrade2.onclick = () => buyUpgrade('upgrade2', 4);
upgradeElements.upgrade3.onclick = () => buyUpgrade('upgrade3', 3);
upgradeElements.upgrade4.onclick = () => buyUpgrade('upgrade4', 2);

// Connect upgrades with lines
function updateLines() {
  const rect1 = upgradeElements.upgrade1.getBoundingClientRect();
  const rect2 = upgradeElements.upgrade2.getBoundingClientRect();
  const rect3 = upgradeElements.upgrade3.getBoundingClientRect();
  const rect4 = upgradeElements.upgrade4.getBoundingClientRect();

  const treeRect = upgradeElements.upgrade1.parentElement.getBoundingClientRect();

  // Compute center coordinates relative to the tree container
  const cx1 = rect1.left + rect1.width / 2 - treeRect.left;
  const cy1 = rect1.top + rect1.height / 2 - treeRect.top;
  const cx2 = rect2.left + rect2.width / 2 - treeRect.left;
  const cy2 = rect2.top + rect2.height / 2 - treeRect.top;
  const cx3 = rect3.left + rect3.width / 2 - treeRect.left;
  const cy3 = rect3.top + rect3.height / 2 - treeRect.top;
  const cx4 = rect4.left + rect4.width / 2 - treeRect.left;
  const cy4 = rect4.top + rect4.height / 2 - treeRect.top;

  const svg = document.querySelector('svg.lines');
  // set viewBox to tree size so coordinates map correctly
  svg.setAttribute('viewBox', `0 0 ${treeRect.width} ${treeRect.height}`);
  // set explicit pixel size so SVG coordinates match getBoundingClientRect computed values
  svg.setAttribute('width', treeRect.width);
  svg.setAttribute('height', treeRect.height);
  svg.style.left = '0px';
  svg.style.top = '0px';

  const line1 = document.getElementById('line1-4');
  const line2 = document.getElementById('line2-4');
  const line3 = document.getElementById('line3-4');

  // Set attributes for diagonal lines from each upgrade center to upgrade4 center
  // Draw a T-join: verticals from each top upgrade center down to a shared horizontal bar (stemY),
  // then a vertical stem up to the center/top of upgrade4.
  const padding = 8; // gap from upgrade edges
  // Position stemY a bit above upgrade4's top edge (not center) so connectors meet above upgrade4
  const upgrade4Top = rect4.top - treeRect.top;
  const stemY = upgrade4Top - padding;

  // Vertical lines from each upgrade center down to stemY
  line1.setAttribute('x1', cx1);
  line1.setAttribute('y1', cy1);
  line1.setAttribute('x2', cx1);
  line1.setAttribute('y2', stemY);

  line2.setAttribute('x1', cx2);
  line2.setAttribute('y1', cy2);
  line2.setAttribute('x2', cx2);
  line2.setAttribute('y2', stemY);

  line3.setAttribute('x1', cx3);
  line3.setAttribute('y1', cy3);
  line3.setAttribute('x2', cx3);
  line3.setAttribute('y2', stemY);

  // Horizontal bar between the leftmost and rightmost verticals at stemY
  const xs = [cx1, cx2, cx3].sort((a,b)=>a-b);
  const lineH = document.getElementById('lineH');
  lineH.setAttribute('x1', xs[0]);
  lineH.setAttribute('y1', stemY);
  lineH.setAttribute('x2', xs[2]);
  lineH.setAttribute('y2', stemY);

  // Stem from horizontal bar down/up to upgrade4 top (center x of upgrade4)
  const lineStem = document.getElementById('lineStem');
  lineStem.setAttribute('x1', cx4);
  lineStem.setAttribute('y1', stemY);
  lineStem.setAttribute('x2', cx4);
  // connect to top-center of upgrade4
  lineStem.setAttribute('y2', upgrade4Top + (rect4.height * 0));

  // Add line from upgrade4 to helium reset button if unlocked
  if (upgradesBought.upgrade4) {
    const heliumButton = document.getElementById('heliumResetButton');
    const heliumRect = heliumButton.getBoundingClientRect();
    const heliumCenterX = heliumRect.left + heliumRect.width / 2 - treeRect.left;
    const heliumCenterY = heliumRect.top + heliumRect.height / 2 - treeRect.top;
    
    const lineHelium = document.getElementById('lineHelium');
    if (lineHelium) {
      lineHelium.setAttribute('x1', cx4);
      lineHelium.setAttribute('y1', cy4);
      lineHelium.setAttribute('x2', heliumCenterX);
      lineHelium.setAttribute('y2', heliumCenterY);
      lineHelium.style.display = 'block';
    }
  } else {
    const lineHelium = document.getElementById('lineHelium');
    if (lineHelium) {
      lineHelium.style.display = 'none';
    }
  }
}

// Reset game
document.getElementById('resetButton').onclick = () => {
  if (confirm("Are you sure you want to reset your data?")) {
    hydrogen = 0;
    hydrogenRate = 1;
    upgradesBought = { upgrade1: false, upgrade2: false, upgrade3: false, upgrade4: false };
    saveGame();
    updateDisplay();
  }
};

// Update lines on load and window resize
window.addEventListener('load', updateLines);
window.addEventListener('resize', updateLines);

// Hide helium reset button initially
document.getElementById('heliumResetButton').style.display = 'none';

// Initial load
loadGame();

// Save Management
document.getElementById('exportButton').onclick = exportSave;

document.getElementById('importButton').onclick = () => {
  document.getElementById('importInput').click();
};

document.getElementById('importInput').onchange = (event) => {
  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const saveData = JSON.parse(e.target.result);
        if (saveData && saveData.playerId) {
          if (confirm('Do you want to load this save? This will replace your current progress.')) {
            // Store the new player ID
            localStorage.setItem('elementalPlayerId', saveData.playerId);
            
            // Load the save data
            hydrogen = saveData.hydrogen || 0;
            hydrogenRate = saveData.hydrogenRate || 1;
            helium = saveData.helium || 0;
            upgradesBought = saveData.upgradesBought || {
              upgrade1: false,
              upgrade2: false,
              upgrade3: false,
              upgrade4: false
            };
            
            // Save and update
            saveGame();
            updateDisplay();
            alert('Save imported successfully!');
          }
        } else {
          alert('Invalid save file format.');
        }
      } catch (e) {
        console.error('Failed to import save:', e);
        alert('Failed to import save file. Make sure it\'s a valid save file.');
      }
    };
    reader.readAsText(file);
  }
};

// Auto save every 5 seconds
setInterval(saveGame, 5000);

// Helium
let helium = 0;
let heliumMultiplier = 1;

// Calculate Helium gain based on current hydrogen amount
function calculateHeliumGain() {
  if (hydrogen < 1000) return 0; // avoid negative/NaN
  return Math.floor(Math.pow(Math.log(hydrogen / 1000), 10));
}

// Update display to include Helium
function updateDisplay() {
  hydrogenDisplay.textContent = hydrogen.toLocaleString();
  hydrogenRateDisplay.textContent = hydrogenRate.toLocaleString();
  
  // Show/hide and update helium information
  const heliumInfo = document.getElementById('heliumInfo');
  if (upgradesBought.upgrade4) {
    heliumInfo.style.display = 'block';
    document.getElementById('helium').textContent = helium.toLocaleString();
    document.getElementById('heliumGain').textContent = calculateHeliumGain().toLocaleString();
  } else {
    heliumInfo.style.display = 'none';
  }
  
  updateUpgradeStates();
  updateLines();
}

// Main reset button handler
document.getElementById('resetButton').onclick = () => {
  if (confirm("Are you sure you want to reset your data?")) {
    hydrogen = 0;
    hydrogenRate = 1;
    helium = 0;
    upgradesBought = { 
      upgrade1: false, 
      upgrade2: false, 
      upgrade3: false, 
      upgrade4: false 
    };
    saveGame();
    updateDisplay();
  }
};

// Helium reset button handler
document.getElementById('heliumResetButton').onclick = () => {
  if (confirm("Are you sure you want to reset for Helium?")) {
    const heliumGain = calculateHeliumGain();
    helium += heliumGain;

    // Reset Hydrogen and upgrades
    hydrogen = 0;
    hydrogenRate = 1;
    upgradesBought = { upgrade1: false, upgrade2: false, upgrade3: false };

    saveGame();
    updateDisplay();

    alert(`You gained ${heliumGain} Helium!`);
  }
};

// Main game loop with Helium multiplier
setInterval(() => {
  hydrogen += hydrogenRate * heliumMultiplier;
  updateDisplay();
}, 1000);

</script>
</body>
</html>

